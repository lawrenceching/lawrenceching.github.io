<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[IMLC.ME]]></title>
  <link href="http://www.imlc.me/atom.xml" rel="self"/>
  <link href="http://www.imlc.me/"/>
  <updated>2016-04-18T11:57:15+08:00</updated>
  <id>http://www.imlc.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Studio 更新 Android 6.0 之后无法找到 org.apache.http 包的问题]]></title>
    <link href="http://www.imlc.me/593.html"/>
    <updated>2016-04-18T12:00:18+08:00</updated>
    <id>http://www.imlc.me/593.html</id>
    <content type="html"><![CDATA[
<p>这么重要的问题竟然没有事先说明，太过分了。<br/>
今天更新了 Android 6.0 的 SDK 后发现项目一片红，吓尿了。<br/>
直接引用把：<a href="http://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-apache-http-client">http://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-apache-http-client</a><br/>
Android 6.0 release removes support for the Apache HTTP client. If your app is using this client and targets Android 2.3 (API level 9) or higher, use the <a href="http://developer.android.com/reference/java/net/HttpURLConnection.html">HttpURLConnection</a> class instead. This API is more efficient because it reduces network use through transparent compression and response caching, and minimizes power consumption. To continue using the Apache HTTP APIs, you must first declare the following compile-time dependency in your <strong>build.gradle</strong> file:</p>

<pre><code>android {
    useLibrary &#39;org.apache.http.legacy&#39;
}
</code></pre>

<p>大概意思就是，Android 6.0不再支持 Apache HTTP client。 请使用 <a href="http://developer.android.com/reference/java/net/HttpURLConnection.html">HttpURLConnection</a> 代替。想要继续使用 Apache HTTP client 的，请添加如上代码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MX4 PRO DDMS 无法访问data文件夹]]></title>
    <link href="http://www.imlc.me/596.html"/>
    <updated>2016-04-18T11:55:50+08:00</updated>
    <id>http://www.imlc.me/596.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>开启手机的Root权限。（开放Root权限会失去保修，慎重考虑）</p></li>
<li><p>在 Terminal 下定位到 sdk/platform-tools 文件夹下，运行</p></li>
</ol>

<pre><code>su
chmod 777 /data
</code></pre>

<p>因为 adb shell 的无法添加-R参数递归修改权限，所以用adb必须要一级一级文件夹修改权限，而且&hellip;我运行chmod后提示“Unable to chmod /data: Operation not permitted ”。所以..</p>

<ol>
<li>下载 Root Explorer，直接递归修改整个/data文件夹， done!</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Imports TSMessages into Swift project]]></title>
    <link href="http://www.imlc.me/600.html"/>
    <updated>2016-04-17T13:11:38+08:00</updated>
    <id>http://www.imlc.me/600.html</id>
    <content type="html"><![CDATA[
<p>Following the document of TSMessages, I meet a trouble:<br/>
Could not read TSMessages config file from main bundle with name<br/>
As mentioned on the page GitHub issue, I fixed the first trouble I met.<br/>
Change pod file to:</p>

<pre><code>pod &#39;TSMessages&#39;, :git =&gt; &#39;https://github.com/KrauseFx/TSMessages.git&#39;
</code></pre>

<p>The problem has been fixed in the master branch but the author do not commit it to Pod yet.<br/>
 <br/>
The second problem is that the easiest way to use TSMessages do not works.</p>

<pre><code>[TSMessage showNotificationWithTitle:@&quot;Your Title&quot;
                                subtitle:@&quot;A description&quot;
                                    type:TSMessageNotificationTypeError];
</code></pre>

<p>in swift:</p>

<pre><code>TSMessage.showNotificationWithTitle(&quot;Title&quot;, subtitle:&quot;subtitle&quot;, type:TSMessageNotificationType.Error)
</code></pre>

<p>Do nothing on my project.<br/>
I has to use an another method and it works fine.</p>

<pre><code>TSMessage.showNotificationInViewController(self, title: &quot;Title&quot;, subtitle: &quot;Subtitle&quot;, type: TSMessageNotificationType.Error)
</code></pre>

<p>I do not figure it out why.</p>

<p>TAG: iOS, TSMessages, Swift</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论文参考文献生成工具]]></title>
    <link href="http://www.imlc.me/reference-generator.html"/>
    <updated>2016-04-17T00:56:36+08:00</updated>
    <id>http://www.imlc.me/reference-generator.html</id>
    <content type="html"><![CDATA[
<p>本工具根据 GB/T 7714-2005 的说明生成参考文献条目。<br/>
目前项目源代码托管在 <a href="https://coding.net/u/lawrenceching/p/reference-generator/git">Coding.net</a> 上。尚处于开发阶段。</p>

<p>如果有什么问题可以直接到 Coding.net 上留言。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Integer 缓存机制的小坑点]]></title>
    <link href="http://www.imlc.me/605.html"/>
    <updated>2016-04-16T23:52:11+08:00</updated>
    <id>http://www.imlc.me/605.html</id>
    <content type="html"><![CDATA[
<p>Integer 是 Java 5 引入的新特性，该特性能节省内存和改善性能。同样被引入缓存机制的还有 Byte，Short，Long，Character，缓存范围都是在 [-128,127] （Character是在[0,127]）之间。</p>

<p>但是有几点需要注意的是：<br/>
1. 对 Integer 对象引入了 IntegerCache 类，其他封装类型也有对应的 XxxCache。<br/>
2. 该缓存特性只有在 autoboxing 过程中使用，换言之，使用 constructor 创建的 Integer 并不能被缓存。<br/>
3. 因为缓存机制的存在，在缓存范围内的对象都来自同一个缓存。带来的副作用是使用“==”地址比较运算符比较两个看似不一样的对象，得到的是 true。网上其他文章的说法是因而可以使用 == 来比较直接比较两个对象的值。但我觉得这样理解容易造成偏差。Java 规范并没有约定 [-128,127] 的范围内 == 用作值比较，这只是一个副作用。<br/>
4. 只有 Integer 对象可以通过指定 JVM 启动参数来修改缓存上限。</p>

<pre><code>-XX:AutoBoxCacheMax=size
</code></pre>

<p>所以说写代码的时候还是不要把==用作值比较。<br/>
 <br/>
老实说这个缓存特性带来的不一致性要是导致了什么BUG实在很难排查。当用了这个特性写了点什么之后，难保后来者不会产生迷惑。所以日常编码中还是尽量避开这个点。<br/>
 <br/>
简单到爆的实验代码：<br/>
简单地验证Java Integer缓存特性</p>

<pre><code>import com.sun.istack.internal.NotNull;
 
/**
 * Created by Lawrence on 15/11/9.
 */
public class Main {
    public static void main(String[] argv){
        Integer int1 = 100;
        Integer int2 = 100;
 
        if(int1==int2){
            print(&quot;int1 is equal to int2&quot;);
        } else {
            print(&quot;int1 is not equal to int2&quot;);
        }
        // prints &quot;int1 is equal to int2&quot;
 
        Integer int3 = 2333;
        Integer int4 = 2333;
 
        if(int3==int4){
            print(&quot;int3 is equal to int4&quot;);
        } else {
            print(&quot;int3 is not equal to int4&quot;);
        }
        // prints &quot;int3 is not equal to int4&quot;
 
        Integer int5 = 100;
        Integer int6 = new Integer(100);
 
        if(int5==int6){
            print(&quot;int5 is equal to int6&quot;);
        } else {
            print(&quot;int5 is not equal to int6&quot;);
        }
        // prints &quot;int5 is not equal to int6&quot;
    }
 
    public static void print(String str){
        System.out.println(str);
    }
 
}
</code></pre>

]]></content>
  </entry>
  
</feed>
